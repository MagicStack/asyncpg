

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>asyncpg.pool &mdash; asyncpg Documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="asyncpg Documentation" href="../../index.html"/>
        <link rel="up" title="asyncpg" href="../asyncpg.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> asyncpg
          

          
          </a>

          
            
            
              <div class="version">
                0.23.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">asyncpg Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">asyncpg</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../asyncpg.html">asyncpg</a> &raquo;</li>
        
      <li>asyncpg.pool</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for asyncpg.pool</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2016-present the asyncpg authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of asyncpg and is released under</span>
<span class="c1"># the Apache 2.0 License: http://www.apache.org/licenses/LICENSE-2.0</span>


<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">connection</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">connect_utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">protocol</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PoolConnectionProxyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attrname</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attrname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attrname</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">meth</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">wrapper</span> <span class="o">=</span> <span class="n">mcls</span><span class="o">.</span><span class="n">_wrap_connection_method</span><span class="p">(</span><span class="n">attrname</span><span class="p">)</span>
                <span class="n">wrapper</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
                <span class="n">dct</span><span class="p">[</span><span class="n">attrname</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span>

            <span class="k">if</span> <span class="s1">&#39;__doc__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
                <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="o">.</span><span class="vm">__doc__</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Needed for Python 3.5 to handle `wrap` class keyword argument.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_wrap_connection_method</span><span class="p">(</span><span class="n">meth_name</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">call_con_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># This method will be owned by PoolConnectionProxy class.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span>
                    <span class="s1">&#39;cannot call Connection.</span><span class="si">{}</span><span class="s1">(): &#39;</span>
                    <span class="s1">&#39;connection has been released back to the pool&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">meth_name</span><span class="p">))</span>

            <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">meth_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">meth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">call_con_method</span>


<span class="k">class</span> <span class="nc">PoolConnectionProxy</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">_ConnectionProxy</span><span class="p">,</span>
                          <span class="n">metaclass</span><span class="o">=</span><span class="n">PoolConnectionProxyMeta</span><span class="p">,</span>
                          <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_con&#39;</span><span class="p">,</span> <span class="s1">&#39;_holder&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">holder</span><span class="p">:</span> <span class="s1">&#39;PoolConnectionHolder&#39;</span><span class="p">,</span>
                 <span class="n">con</span><span class="p">:</span> <span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="n">con</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_holder</span> <span class="o">=</span> <span class="n">holder</span>
        <span class="n">con</span><span class="o">.</span><span class="n">_set_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># Proxy all unresolved attributes to the wrapped Connection object.</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_detach</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">con</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">con</span><span class="o">.</span><span class="n">_set_proxy</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">con</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{classname}</span><span class="s1"> [released] </span><span class="si">{id:#x}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">classname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{classname}</span><span class="s1"> </span><span class="si">{con!r}</span><span class="s1"> </span><span class="si">{id:#x}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">classname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">PoolConnectionHolder</span><span class="p">:</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_con&#39;</span><span class="p">,</span> <span class="s1">&#39;_pool&#39;</span><span class="p">,</span> <span class="s1">&#39;_loop&#39;</span><span class="p">,</span> <span class="s1">&#39;_proxy&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_max_queries&#39;</span><span class="p">,</span> <span class="s1">&#39;_setup&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_max_inactive_time&#39;</span><span class="p">,</span> <span class="s1">&#39;_in_use&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_inactive_callback&#39;</span><span class="p">,</span> <span class="s1">&#39;_timeout&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_generation&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">max_queries</span><span class="p">,</span> <span class="n">setup</span><span class="p">,</span> <span class="n">max_inactive_time</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span> <span class="o">=</span> <span class="n">pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_queries</span> <span class="o">=</span> <span class="n">max_queries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_inactive_time</span> <span class="o">=</span> <span class="n">max_inactive_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span> <span class="o">=</span> <span class="n">setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: asyncio.Future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalClientError</span><span class="p">(</span>
                <span class="s1">&#39;PoolConnectionHolder.connect() called while another &#39;</span>
                <span class="s1">&#39;connection already exists&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_get_new_connection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cancel_inactive_callback</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_inactive_callback</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PoolConnectionProxy</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">is_closed</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_generation</span><span class="p">:</span>
            <span class="c1"># Connections have been expired, re-connect the holder.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cancel_inactive_callback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="o">=</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">PoolConnectionProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="c1"># If a user-defined `setup` function fails, we don&#39;t</span>
                <span class="c1"># know if the connection is safe for re-use, hence</span>
                <span class="c1"># we close it.  A new connection will be created</span>
                <span class="c1"># when `acquire` is called again.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Use `close()` to close the connection gracefully.</span>
                    <span class="c1"># An exception in `setup` isn&#39;t necessarily caused</span>
                    <span class="c1"># by an IO or a protocol error.  close() will</span>
                    <span class="c1"># do the necessary cleanup via _release_on_close().</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ex</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">proxy</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalClientError</span><span class="p">(</span>
                <span class="s1">&#39;PoolConnectionHolder.release() called on &#39;</span>
                <span class="s1">&#39;a free connection holder&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">is_closed</span><span class="p">():</span>
            <span class="c1"># When closing, pool connections perform the necessary</span>
            <span class="c1"># cleanup, so we don&#39;t have to do anything else here.</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_protocol</span><span class="o">.</span><span class="n">queries_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_queries</span><span class="p">:</span>
            <span class="c1"># The connection has reached its maximum utilization limit,</span>
            <span class="c1"># so close it.  Connection.close() will call _release().</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_generation</span><span class="p">:</span>
            <span class="c1"># The connection has expired because it belongs to</span>
            <span class="c1"># an older generation (Pool.expire_connections() has</span>
            <span class="c1"># been called.)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">budget</span> <span class="o">=</span> <span class="n">timeout</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_protocol</span><span class="o">.</span><span class="n">_is_cancelling</span><span class="p">():</span>
                <span class="c1"># If the connection is in cancellation state,</span>
                <span class="c1"># wait for the cancellation</span>
                <span class="n">started</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                <span class="k">await</span> <span class="n">compat</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_protocol</span><span class="o">.</span><span class="n">_wait_for_cancellation</span><span class="p">(),</span>
                    <span class="n">budget</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">budget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">budget</span> <span class="o">-=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">started</span>

            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">budget</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="c1"># If the `reset` call failed, terminate the connection.</span>
            <span class="c1"># A new one will be created when `acquire` is called</span>
            <span class="c1"># again.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># An exception in `reset` is most likely caused by</span>
                <span class="c1"># an IO error, so terminate the connection.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ex</span>

        <span class="c1"># Free this connection holder and invalidate the</span>
        <span class="c1"># connection proxy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_release</span><span class="p">()</span>

        <span class="c1"># Rearm the connection inactivity timer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_inactive_callback</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">wait_until_released</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Connection.close() will call _release_on_close() to</span>
            <span class="c1"># finish holder cleanup.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Connection.terminate() will call _release_on_close() to</span>
            <span class="c1"># finish holder cleanup.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_inactive_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalClientError</span><span class="p">(</span>
                <span class="s1">&#39;pool connection inactivity timer already exists&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_inactive_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_inactive_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deactivate_inactive_connection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cancel_inactive_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inactive_callback</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_deactivate_inactive_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalClientError</span><span class="p">(</span>
                <span class="s1">&#39;attempting to deactivate an acquired connection&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The connection is idle and not in use, so it&#39;s fine to</span>
            <span class="c1"># use terminate() instead of close().</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="c1"># Must call clear_connection, because _deactivate_connection</span>
            <span class="c1"># is called when the connection is *not* checked out, and</span>
            <span class="c1"># so terminate() above will not call the below.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_release_on_close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_release_on_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cancel_inactive_callback</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_release</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_con</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release this connection holder.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The holder is not checked out.</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_use</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Deinitialize the connection proxy.  All subsequent</span>
        <span class="c1"># operations on it will fail.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Put ourselves back to the pool queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pool</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Pool"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool">[docs]</a><span class="k">class</span> <span class="nc">Pool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A connection pool.</span>

<span class="sd">    Connection pool can be used to manage a set of connections to the database.</span>
<span class="sd">    Connections are first acquired from the pool, then used, and then released</span>
<span class="sd">    back to the pool.  Once a connection is released, it&#39;s reset to close all</span>
<span class="sd">    open cursors and other resources *except* prepared statements.</span>

<span class="sd">    Pools are created by calling :func:`~asyncpg.pool.create_pool`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;_queue&#39;</span><span class="p">,</span> <span class="s1">&#39;_loop&#39;</span><span class="p">,</span> <span class="s1">&#39;_minsize&#39;</span><span class="p">,</span> <span class="s1">&#39;_maxsize&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_init&#39;</span><span class="p">,</span> <span class="s1">&#39;_connect_args&#39;</span><span class="p">,</span> <span class="s1">&#39;_connect_kwargs&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_working_addr&#39;</span><span class="p">,</span> <span class="s1">&#39;_working_config&#39;</span><span class="p">,</span> <span class="s1">&#39;_working_params&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_holders&#39;</span><span class="p">,</span> <span class="s1">&#39;_initialized&#39;</span><span class="p">,</span> <span class="s1">&#39;_initializing&#39;</span><span class="p">,</span> <span class="s1">&#39;_closing&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_closed&#39;</span><span class="p">,</span> <span class="s1">&#39;_connection_class&#39;</span><span class="p">,</span> <span class="s1">&#39;_record_class&#39;</span><span class="p">,</span> <span class="s1">&#39;_generation&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_setup&#39;</span><span class="p">,</span> <span class="s1">&#39;_max_queries&#39;</span><span class="p">,</span> <span class="s1">&#39;_max_inactive_connection_lifetime&#39;</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">connect_args</span><span class="p">,</span>
                 <span class="n">min_size</span><span class="p">,</span>
                 <span class="n">max_size</span><span class="p">,</span>
                 <span class="n">max_queries</span><span class="p">,</span>
                 <span class="n">max_inactive_connection_lifetime</span><span class="p">,</span>
                 <span class="n">setup</span><span class="p">,</span>
                 <span class="n">init</span><span class="p">,</span>
                 <span class="n">loop</span><span class="p">,</span>
                 <span class="n">connection_class</span><span class="p">,</span>
                 <span class="n">record_class</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">connect_kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connect_args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Passing multiple positional arguments to asyncpg.Pool &quot;</span>
                <span class="s2">&quot;constructor is deprecated and will be removed in &quot;</span>
                <span class="s2">&quot;asyncpg 0.17.0.  The non-deprecated form is &quot;</span>
                <span class="s2">&quot;asyncpg.Pool(&lt;dsn&gt;, **kwargs)&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">loop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span> <span class="o">=</span> <span class="n">loop</span>

        <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;max_size is expected to be greater than zero&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;min_size is expected to be greater or equal to zero&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;min_size is greater than max_size&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_queries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;max_queries is expected to be greater than zero&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_inactive_connection_lifetime</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;max_inactive_connection_lifetime is expected to be greater &#39;</span>
                <span class="s1">&#39;or equal to zero&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">connection_class</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;connection_class is expected to be a subclass of &#39;</span>
                <span class="s1">&#39;asyncpg.Connection, got </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">connection_class</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">record_class</span><span class="p">,</span> <span class="n">protocol</span><span class="o">.</span><span class="n">Record</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;record_class is expected to be a subclass of &#39;</span>
                <span class="s1">&#39;asyncpg.Record, got </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">record_class</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_minsize</span> <span class="o">=</span> <span class="n">min_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span> <span class="o">=</span> <span class="n">max_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initializing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_working_addr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_config</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_params</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connection_class</span> <span class="o">=</span> <span class="n">connection_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_class</span> <span class="o">=</span> <span class="n">record_class</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_closing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span> <span class="o">=</span> <span class="n">connect_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_kwargs</span> <span class="o">=</span> <span class="n">connect_kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span> <span class="o">=</span> <span class="n">setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_queries</span> <span class="o">=</span> <span class="n">max_queries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_inactive_connection_lifetime</span> <span class="o">=</span> \
            <span class="n">max_inactive_connection_lifetime</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_async__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span>
                <span class="s1">&#39;pool is being initialized in another task&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span><span class="s1">&#39;pool is closed&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initializing</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initializing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">LifoQueue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">PoolConnectionHolder</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">max_queries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_queries</span><span class="p">,</span>
                <span class="n">max_inactive_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_inactive_connection_lifetime</span><span class="p">,</span>
                <span class="n">setup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minsize</span><span class="p">:</span>
            <span class="c1"># Since we use a LIFO queue, the first items in the queue will be</span>
            <span class="c1"># the last ones in `self._holders`.  We want to pre-connect the</span>
            <span class="c1"># first few connections in the queue, therefore we want to walk</span>
            <span class="c1"># `self._holders` in reverse.</span>

            <span class="c1"># Connect the first connection holder in the queue so that it</span>
            <span class="c1"># can record `_working_addr` and `_working_opts`, which will</span>
            <span class="c1"># speed up successive connection attempts.</span>
            <span class="n">first_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># type: PoolConnectionHolder</span>
            <span class="k">await</span> <span class="n">first_ch</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minsize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">connect_tasks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                    <span class="c1"># `minsize - 1` because we already have first_ch</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">connect_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">connect</span><span class="p">())</span>

                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">connect_tasks</span><span class="p">)</span>

<div class="viewcode-block" id="Pool.set_connect_args"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.set_connect_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_connect_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dsn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">connect_kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set the new connection arguments for this pool.</span>

<span class="sd">        The new connection arguments will be used for all subsequent</span>
<span class="sd">        new connection attempts.  Existing connections will remain until</span>
<span class="sd">        they expire. Use :meth:`Pool.expire_connections()</span>
<span class="sd">        &lt;asyncpg.pool.Pool.expire_connections&gt;` to expedite the connection</span>
<span class="sd">        expiry.</span>

<span class="sd">        :param str dsn:</span>
<span class="sd">            Connection arguments specified using as a single string in</span>
<span class="sd">            the following format:</span>
<span class="sd">            ``postgres://user:pass@host:port/database?option=value``.</span>

<span class="sd">        :param \*\*connect_kwargs:</span>
<span class="sd">            Keyword arguments for the :func:`~asyncpg.connection.connect`</span>
<span class="sd">            function.</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">dsn</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_kwargs</span> <span class="o">=</span> <span class="n">connect_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_addr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_config</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_working_params</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_get_new_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_working_addr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># First connection attempt on this pool.</span>
            <span class="n">con</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connection</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">,</span>
                <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="p">,</span>
                <span class="n">connection_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection_class</span><span class="p">,</span>
                <span class="n">record_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_record_class</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_kwargs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_working_addr</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">_addr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_working_config</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">_config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_working_params</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">_params</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We&#39;ve connected before and have a resolved address,</span>
            <span class="c1"># and parsed options and config.</span>
            <span class="n">con</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connect_utils</span><span class="o">.</span><span class="n">_connect_addr</span><span class="p">(</span>
                <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="p">,</span>
                <span class="n">addr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_working_addr</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_working_params</span><span class="o">.</span><span class="n">connect_timeout</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_working_config</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_working_params</span><span class="p">,</span>
                <span class="n">connection_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_connection_class</span><span class="p">,</span>
                <span class="n">record_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_record_class</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="c1"># If a user-defined `init` function fails, we don&#39;t</span>
                <span class="c1"># know if the connection is safe for re-use, hence</span>
                <span class="c1"># we close it.  A new connection will be created</span>
                <span class="c1"># when `acquire` is called again.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Use `close()` to close the connection gracefully.</span>
                    <span class="c1"># An exception in `init` isn&#39;t necessarily caused</span>
                    <span class="c1"># by an IO or a protocol error.  close() will</span>
                    <span class="c1"># do the necessary cleanup via _release_on_close().</span>
                    <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ex</span>

        <span class="k">return</span> <span class="n">con</span>

<div class="viewcode-block" id="Pool.execute"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.execute">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Execute an SQL command (or commands).</span>

<span class="sd">        Pool performs this operation using one of its connections.  Other than</span>
<span class="sd">        that, it behaves identically to</span>
<span class="sd">        :meth:`Connection.execute() &lt;connection.Connection.execute&gt;`.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="Pool.executemany"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.executemany">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">executemany</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute an SQL *command* for each sequence of arguments in *args*.</span>

<span class="sd">        Pool performs this operation using one of its connections.  Other than</span>
<span class="sd">        that, it behaves identically to</span>
<span class="sd">        :meth:`Connection.executemany() &lt;connection.Connection.executemany&gt;`.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="Pool.fetch"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.fetch">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Run a query and return the results as a list of :class:`Record`.</span>

<span class="sd">        Pool performs this operation using one of its connections.  Other than</span>
<span class="sd">        that, it behaves identically to</span>
<span class="sd">        :meth:`Connection.fetch() &lt;connection.Connection.fetch&gt;`.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="Pool.fetchval"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.fetchval">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetchval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run a query and return a value in the first row.</span>

<span class="sd">        Pool performs this operation using one of its connections.  Other than</span>
<span class="sd">        that, it behaves identically to</span>
<span class="sd">        :meth:`Connection.fetchval() &lt;connection.Connection.fetchval&gt;`.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">fetchval</span><span class="p">(</span>
                <span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="Pool.fetchrow"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.fetchrow">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetchrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run a query and return the first row.</span>

<span class="sd">        Pool performs this operation using one of its connections.  Other than</span>
<span class="sd">        that, it behaves identically to</span>
<span class="sd">        :meth:`Connection.fetchrow() &lt;connection.Connection.fetchrow&gt;`.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span> <span class="k">as</span> <span class="n">con</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">con</span><span class="o">.</span><span class="n">fetchrow</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span></div>

<div class="viewcode-block" id="Pool.acquire"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.acquire">[docs]</a>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a database connection from the pool.</span>

<span class="sd">        :param float timeout: A timeout for acquiring a Connection.</span>
<span class="sd">        :return: An instance of :class:`~asyncpg.connection.Connection`.</span>

<span class="sd">        Can be used in an ``await`` expression or with an ``async with`` block.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            async with pool.acquire() as con:</span>
<span class="sd">                await con.execute(...)</span>

<span class="sd">        Or:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            con = await pool.acquire()</span>
<span class="sd">            try:</span>
<span class="sd">                await con.execute(...)</span>
<span class="sd">            finally:</span>
<span class="sd">                await pool.release(con)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PoolAcquireContext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span></div>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">_acquire_impl</span><span class="p">():</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  <span class="c1"># type: PoolConnectionHolder</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">proxy</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ch</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>  <span class="c1"># type: PoolConnectionProxy</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Record the timeout, as we will apply it by default</span>
                <span class="c1"># in release().</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="n">timeout</span>
                <span class="k">return</span> <span class="n">proxy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span><span class="s1">&#39;pool is closing&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_init</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">_acquire_impl</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">compat</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span>
                <span class="n">_acquire_impl</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>

<div class="viewcode-block" id="Pool.release"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.release">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a database connection back to the pool.</span>

<span class="sd">        :param Connection connection:</span>
<span class="sd">            A :class:`~asyncpg.connection.Connection` object to release.</span>
<span class="sd">        :param float timeout:</span>
<span class="sd">            A timeout for releasing the connection.  If not specified, defaults</span>
<span class="sd">            to the timeout provided in the corresponding call to the</span>
<span class="sd">            :meth:`Pool.acquire() &lt;asyncpg.pool.Pool.acquire&gt;` method.</span>

<span class="sd">        .. versionchanged:: 0.14.0</span>
<span class="sd">            Added the *timeout* parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PoolConnectionProxy</span> <span class="ow">or</span>
                <span class="n">connection</span><span class="o">.</span><span class="n">_holder</span><span class="o">.</span><span class="n">_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span>
                <span class="s1">&#39;Pool.release() received invalid connection: &#39;</span>
                <span class="s1">&#39;</span><span class="si">{connection!r}</span><span class="s1"> is not a member of this pool&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Already released, do nothing.</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_init</span><span class="p">()</span>

        <span class="c1"># Let the connection do its internal housekeeping when its released.</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_on_release</span><span class="p">()</span>

        <span class="n">ch</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">_holder</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">_timeout</span>

        <span class="c1"># Use asyncio.shield() to guarantee that task cancellation</span>
        <span class="c1"># does not prevent the connection from being returned to the</span>
        <span class="c1"># pool properly.</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">shield</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span></div>

<div class="viewcode-block" id="Pool.close"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.close">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to gracefully close all connections in the pool.</span>

<span class="sd">        Wait until all pool connections are released, close them and</span>
<span class="sd">        shut down the pool.  If any error (including cancellation) occurs</span>
<span class="sd">        in ``close()`` the pool will terminate by calling</span>
<span class="sd">        :meth:`Pool.terminate() &lt;pool.Pool.terminate&gt;`.</span>

<span class="sd">        It is advisable to use :func:`python:asyncio.wait_for` to set</span>
<span class="sd">        a timeout.</span>

<span class="sd">        .. versionchanged:: 0.16.0</span>
<span class="sd">            ``close()`` now waits until all pool connections are released</span>
<span class="sd">            before closing them and the pool.  Errors raised in ``close()``</span>
<span class="sd">            will cause immediate pool termination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_init</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_closing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">warning_callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">warning_callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
                <span class="mi">60</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_long_close</span><span class="p">)</span>

            <span class="n">release_coros</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">wait_until_released</span><span class="p">()</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">]</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">release_coros</span><span class="p">)</span>

            <span class="n">close_coros</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">]</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">close_coros</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">raise</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warning_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warning_callback</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closing</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_warn_on_long_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Pool.close() is taking over 60 seconds to complete. &#39;</span>
                       <span class="s1">&#39;Check if you have any unreleased connections left. &#39;</span>
                       <span class="s1">&#39;Use asyncio.wait_for() to set a timeout for &#39;</span>
                       <span class="s1">&#39;Pool.close().&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Pool.terminate"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Terminate all connections in the pool.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_init</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">:</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Pool.expire_connections"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.Pool.expire_connections">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">expire_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire all currently open connections.</span>

<span class="sd">        Cause all currently open connections to get replaced on the</span>
<span class="sd">        next :meth:`~asyncpg.pool.Pool.acquire()` call.</span>

<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generation</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_check_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span>
                    <span class="s1">&#39;pool is being initialized, but not yet ready: &#39;</span>
                    <span class="s1">&#39;likely there is a race between creating a pool and &#39;</span>
                    <span class="s1">&#39;using it&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span><span class="s1">&#39;pool is not initialized&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span><span class="s1">&#39;pool is closed&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_drop_statement_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Drop statement cache for all connections in the pool.</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_drop_local_statement_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_drop_type_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Drop type codec cache for all connections in the pool.</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_holders</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">_con</span><span class="o">.</span><span class="n">_drop_local_type_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async__init__</span><span class="p">()</span><span class="o">.</span><span class="fm">__await__</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async__init__</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">PoolAcquireContext</span><span class="p">:</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">,</span> <span class="s1">&#39;connection&#39;</span><span class="p">,</span> <span class="s1">&#39;done&#39;</span><span class="p">,</span> <span class="s1">&#39;pool&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InterfaceError</span><span class="p">(</span><span class="s1">&#39;a connection is already acquired&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">_acquire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">_acquire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span><span class="o">.</span><span class="fm">__await__</span><span class="p">()</span>


<div class="viewcode-block" id="create_pool"><a class="viewcode-back" href="../../api/index.html#asyncpg.pool.create_pool">[docs]</a><span class="k">def</span> <span class="nf">create_pool</span><span class="p">(</span><span class="n">dsn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                <span class="n">min_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">max_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">max_queries</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
                <span class="n">max_inactive_connection_lifetime</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span>
                <span class="n">setup</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">loop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">connection_class</span><span class="o">=</span><span class="n">connection</span><span class="o">.</span><span class="n">Connection</span><span class="p">,</span>
                <span class="n">record_class</span><span class="o">=</span><span class="n">protocol</span><span class="o">.</span><span class="n">Record</span><span class="p">,</span>
                <span class="o">**</span><span class="n">connect_kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a connection pool.</span>

<span class="sd">    Can be used either with an ``async with`` block:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        async with asyncpg.create_pool(user=&#39;postgres&#39;,</span>
<span class="sd">                                       command_timeout=60) as pool:</span>
<span class="sd">            await pool.fetch(&#39;SELECT 1&#39;)</span>

<span class="sd">    Or to perform multiple operations on a single connection:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        async with asyncpg.create_pool(user=&#39;postgres&#39;,</span>
<span class="sd">                                       command_timeout=60) as pool:</span>
<span class="sd">            async with pool.acquire() as con:</span>
<span class="sd">                await con.execute(&#39;&#39;&#39;</span>
<span class="sd">                   CREATE TABLE names (</span>
<span class="sd">                      id serial PRIMARY KEY,</span>
<span class="sd">                      name VARCHAR (255) NOT NULL)</span>
<span class="sd">                &#39;&#39;&#39;)</span>
<span class="sd">                await con.fetch(&#39;SELECT 1&#39;)</span>

<span class="sd">    Or directly with ``await`` (not recommended):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        pool = await asyncpg.create_pool(user=&#39;postgres&#39;, command_timeout=60)</span>
<span class="sd">        con = await pool.acquire()</span>
<span class="sd">        try:</span>
<span class="sd">            await con.fetch(&#39;SELECT 1&#39;)</span>
<span class="sd">        finally:</span>
<span class="sd">            await pool.release(con)</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Prepared statements and cursors returned by</span>
<span class="sd">        :meth:`Connection.prepare() &lt;connection.Connection.prepare&gt;` and</span>
<span class="sd">        :meth:`Connection.cursor() &lt;connection.Connection.cursor&gt;` become</span>
<span class="sd">        invalid once the connection is released.  Likewise, all notification</span>
<span class="sd">        and log listeners are removed, and ``asyncpg`` will issue a warning</span>
<span class="sd">        if there are any listener callbacks registered on a connection that</span>
<span class="sd">        is being released to the pool.</span>

<span class="sd">    :param str dsn:</span>
<span class="sd">        Connection arguments specified using as a single string in</span>
<span class="sd">        the following format:</span>
<span class="sd">        ``postgres://user:pass@host:port/database?option=value``.</span>

<span class="sd">    :param \*\*connect_kwargs:</span>
<span class="sd">        Keyword arguments for the :func:`~asyncpg.connection.connect`</span>
<span class="sd">        function.</span>

<span class="sd">    :param Connection connection_class:</span>
<span class="sd">        The class to use for connections.  Must be a subclass of</span>
<span class="sd">        :class:`~asyncpg.connection.Connection`.</span>

<span class="sd">    :param type record_class:</span>
<span class="sd">        If specified, the class to use for records returned by queries on</span>
<span class="sd">        the connections in this pool.  Must be a subclass of</span>
<span class="sd">        :class:`~asyncpg.Record`.</span>

<span class="sd">    :param int min_size:</span>
<span class="sd">        Number of connection the pool will be initialized with.</span>

<span class="sd">    :param int max_size:</span>
<span class="sd">        Max number of connections in the pool.</span>

<span class="sd">    :param int max_queries:</span>
<span class="sd">        Number of queries after a connection is closed and replaced</span>
<span class="sd">        with a new connection.</span>

<span class="sd">    :param float max_inactive_connection_lifetime:</span>
<span class="sd">        Number of seconds after which inactive connections in the</span>
<span class="sd">        pool will be closed.  Pass ``0`` to disable this mechanism.</span>

<span class="sd">    :param coroutine setup:</span>
<span class="sd">        A coroutine to prepare a connection right before it is returned</span>
<span class="sd">        from :meth:`Pool.acquire() &lt;pool.Pool.acquire&gt;`.  An example use</span>
<span class="sd">        case would be to automatically set up notifications listeners for</span>
<span class="sd">        all connections of a pool.</span>

<span class="sd">    :param coroutine init:</span>
<span class="sd">        A coroutine to initialize a connection when it is created.</span>
<span class="sd">        An example use case would be to setup type codecs with</span>
<span class="sd">        :meth:`Connection.set_builtin_type_codec() &lt;\</span>
<span class="sd">        asyncpg.connection.Connection.set_builtin_type_codec&gt;`</span>
<span class="sd">        or :meth:`Connection.set_type_codec() &lt;\</span>
<span class="sd">        asyncpg.connection.Connection.set_type_codec&gt;`.</span>

<span class="sd">    :param loop:</span>
<span class="sd">        An asyncio event loop instance.  If ``None``, the default</span>
<span class="sd">        event loop will be used.</span>

<span class="sd">    :return: An instance of :class:`~asyncpg.pool.Pool`.</span>

<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       An :exc:`~asyncpg.exceptions.InterfaceError` will be raised on any</span>
<span class="sd">       attempted operation on a released connection.</span>

<span class="sd">    .. versionchanged:: 0.13.0</span>
<span class="sd">       An :exc:`~asyncpg.exceptions.InterfaceError` will be raised on any</span>
<span class="sd">       attempted operation on a prepared statement or a cursor created</span>
<span class="sd">       on a connection that has been released to the pool.</span>

<span class="sd">    .. versionchanged:: 0.13.0</span>
<span class="sd">       An :exc:`~asyncpg.exceptions.InterfaceWarning` will be produced</span>
<span class="sd">       if there are any active listeners (added via</span>
<span class="sd">       :meth:`Connection.add_listener() &lt;connection.Connection.add_listener&gt;`</span>
<span class="sd">       or :meth:`Connection.add_log_listener()</span>
<span class="sd">       &lt;connection.Connection.add_log_listener&gt;`) present on the connection</span>
<span class="sd">       at the moment of its release to the pool.</span>

<span class="sd">    .. versionchanged:: 0.22.0</span>
<span class="sd">       Added the *record_class* parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pool</span><span class="p">(</span>
        <span class="n">dsn</span><span class="p">,</span>
        <span class="n">connection_class</span><span class="o">=</span><span class="n">connection_class</span><span class="p">,</span>
        <span class="n">record_class</span><span class="o">=</span><span class="n">record_class</span><span class="p">,</span>
        <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span><span class="p">,</span>
        <span class="n">max_queries</span><span class="o">=</span><span class="n">max_queries</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
        <span class="n">max_inactive_connection_lifetime</span><span class="o">=</span><span class="n">max_inactive_connection_lifetime</span><span class="p">,</span>
        <span class="o">**</span><span class="n">connect_kwargs</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-present, the asyncpg authors and contributors.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.23.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>